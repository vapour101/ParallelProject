%-Document Type------------------------------------------------------------------------------
\documentclass[12pt,a4paper]{report}
%--------------------------------------------------------------------------------------------

%Packages------------------------------------------------------------------------------------
\usepackage[colorlinks=true,linkcolor=blue]{hyperref} %Using this package will automatically turn references into links.
\usepackage{graphicx}
\usepackage{listings} % Required for insertion of code
\usepackage[]{algorithm2e}
\usepackage{tikz}
\usepackage{verbatim}
\usepackage{subcaption}
\usetikzlibrary{trees}
%---------------------------------------------------------------------------------------------

%Preamble-------------------------------------------------------------------------------------

%End Preamble---------------------------------------------------------------------------------

%Document----------------------------------------------------------------------------------------
\begin{document}
\parindent0pt

%Cover Page---------------------------------------------------------------------------------------
\title{COMS3008: Parallel Computing Assignment}
\author{Tau Merand 908096 \and Vincent Varkevisser 705668}
\maketitle
%Cover Page End-----------------------------------------------------------------------------------
\section*{Introduction}
The game of peg solitaire is a one player game played on a 33 holed cross shaped board that involves jumping pegs over other pegs, in a manner similiar to checkers. The rules are as follows:
\begin{enumerate}
  \item A move consists of jumping a peg over an orthoganal neighbour into an empty space. The peg that was jumped over is then removed from the board.
  \item Pegs can only jump onto an empty space.
  \item The game is won if the final peg is in the centre space.
  \item If no pegs can legally move or the final peg is not in the centre the game is lost.
\end{enumerate}
\begin{figure}[ht]
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \resizebox{\textwidth}{!}{
      \begin{tikzpicture}
        [empty/.style={circle,draw=gray,very thin}, full/.style={circle,draw=black, fill=black ,very thin}]
        \foreach \x in {2,3,4}
          \foreach \y in {0,1, 2,3,4,5,6}
            \path node at (\x,\y) [empty] {}
                  node at (0,2) [empty] {}
                  node at (0,3) [empty] {}
                  node at (0,4) [empty] {}
                  node at (1,2) [empty] {}
                  node at (1,3) [empty] {}
                  node at (1,4) [empty] {}
                  node at (5,2) [empty] {}
                  node at (5,3) [empty] {}
                  node at (5,4) [empty] {}
                  node at (6,2) [empty] {}
                  node at (6,3) [empty] {}
                  node at (6,4) [empty] {}
                  node at (4,4) [full] {}
                  node at (5,4) [full] {}
                  node at (3,5) [full] {};
      \end{tikzpicture}
    }
    \caption{A start state}
  \end{subfigure}\hfill%
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \resizebox{\textwidth}{!}{
      \begin{tikzpicture}
        [empty/.style={circle,draw=gray,very thin}, full/.style={circle,draw=black, fill=black ,very thin}]
        \foreach \x in {2,3,4}
          \foreach \y in {0,1, 2,3,4,5,6}
            \path node at (\x,\y) [empty] {}
                  node at (0,2) [empty] {}
                  node at (0,3) [empty] {}
                  node at (0,4) [empty] {}
                  node at (1,2) [empty] {}
                  node at (1,3) [empty] {}
                  node at (1,4) [empty] {}
                  node at (5,2) [empty] {}
                  node at (5,3) [empty] {}
                  node at (5,4) [empty] {}
                  node at (6,2) [empty] {}
                  node at (6,3) [empty] {}
                  node at (6,4) [empty] {}
                  node at (3,4) [full] {}
                  node at (3,5) [full] {};
      \end{tikzpicture}
    }
    \caption{The right most peg jumps over its left neihgbour}
  \end{subfigure}\hfill%
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \resizebox{\textwidth}{!}{
      \begin{tikzpicture}
        [empty/.style={circle,draw=gray,very thin}, full/.style={circle,draw=black, fill=black ,very thin}]
        \foreach \x in {2,3,4}
          \foreach \y in {0,1, 2,3,4,5,6}
            \path node at (\x,\y) [empty] {}
                  node at (0,2) [empty] {}
                  node at (0,3) [empty] {}
                  node at (0,4) [empty] {}
                  node at (1,2) [empty] {}
                  node at (1,3) [empty] {}
                  node at (1,4) [empty] {}
                  node at (5,2) [empty] {}
                  node at (5,3) [empty] {}
                  node at (5,4) [empty] {}
                  node at (6,2) [empty] {}
                  node at (6,3) [empty] {}
                  node at (6,4) [empty] {}
                  node at (3,3) [full] {};
      \end{tikzpicture}
    }
    \caption{The winning state}
  \end{subfigure}
  \caption{A winning set of valid moves}
\end{figure}
\pagebreak
\section*{Backtracking Search}
Recursive backtracking using depth first search was chosen as the method for state space exploration. The standard backtracking depth first algorithm is as follows: %Vincent TODO
\begin{algorithm}[ht]
  \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
  \Input{An initial, valid board state}
  \Output{A sequence of moves to get from the initial state to the winning state}
  \BlankLine
  $result\leftarrow$ Empty list to store moves from the initial state to the winning state
  $legalMoves\leftarrow$ A list of all the legal moves for the current board\;
  $state\leftarrow$ The current state\;
  \ForEach{m in legalMoves}{
    $state\leftarrow$ The state achieved by performing m\;
    \uIf{state is winning state}{
      return \emph{move}\;
    }
    \uElseIf{state has no legal moves}{
      return \emph{Null}\;
    }
    \Else{
      return BacktrackingDFS(state)\;
    }
  }
 \caption{A standard recursive backtracking using DFS}
\end{algorithm}

But because pegs are indifferentiable, game states where pegs are in the same position are identical, regardless of the moves taken to arrive at that state. Thus exploring the state space looking for a sequence of states leading to the winning state will probably involve evaluating the same states many times. Thus a significant speed up can be achieved by saving states that are known to not lead to the winning state.



\subsection*{Serial Implementation}



\subsection*{Parallel Implementation}

\section*{Results}




\end{document}
